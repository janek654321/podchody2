<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" />
  <title>Mapa</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
  <style>
    html, body, #map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script src="https://unpkg.com/jsts@2.6.1/dist/jsts.min.js"></script>
  <script>
	const koloryStref = {
	  1: 'red',
	  2: 'orange',
	  3: 'black'
	};
	
  
    const map = new ol.Map({
      target: 'map',
      layers: [
        new ol.layer.Tile({ source: new ol.source.OSM()	})
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([18.6, 53.02]),
        zoom: 13
      })
    });

	
	const strefaStore = {};

	const strefaLayer = new ol.layer.Vector({
	  source: new ol.source.Vector(),
	  style: feature => {
		const id = feature.get('id');
		return new ol.style.Style({
		  stroke: new ol.style.Stroke({
			color: koloryStref[id] || 'black',
			width: 3
		  }),
		  fill: null
		});
	  }
	});
	map.addLayer(strefaLayer);
	
	
	
	const maskSource = new ol.source.Vector();
    const maskLayer = new ol.layer.Vector({
      source: maskSource,
      style: new ol.style.Style({
        stroke: null,
        fill: new ol.style.Fill({
          color: 'rgba(100,0,0,0.4)'
        })
      }),
      zIndex: 100
    });
    map.addLayer(maskLayer);
    const extent = ol.proj.get('EPSG:3857').getExtent();
    const worldCoords = [
      [-20037508.342789244, 20037508.342789244],  // NW
      [20037508.342789244, 20037508.342789244],   // NE
      [20037508.342789244, -20037508.342789244],  // SE
      [-20037508.342789244, -20037508.342789244], // SW
      [-20037508.342789244, 20037508.342789244]   // zamknięcie NW
    ];
	
		
	
	
    const markersLayer = new ol.layer.Vector({
      source: new ol.source.Vector()
    });
    map.addLayer(markersLayer);

    const markerStore = {};
	
	const scaleLineControl = new ol.control.ScaleLine();
	map.addControl(scaleLineControl);
	
    function computeDestinationPoint([lon, lat], distance, bearing) {
      const R = 6371000;
      const δ = distance / R;
      const θ = bearing * Math.PI / 180;
      const φ1 = lat * Math.PI / 180;
      const λ1 = lon * Math.PI / 180;
      const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) +
                             Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));
      const λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(δ) * Math.cos(φ1),
                                 Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
      return [λ2 * 180 / Math.PI, φ2 * 180 / Math.PI];
    }

    function zone(id, lo, la, promienMetry) {
	  const center = [lo, la];
	  const radius = promienMetry;

	  const points = [];
	  const numPoints = 64;

	  for (let i = 0; i < numPoints; ++i) {
		const angleDeg = (360 * i) / numPoints;
		const dest = computeDestinationPoint(center, radius, angleDeg);
		points.push(ol.proj.fromLonLat(dest));
	  }
	  points.push(points[0]);

	  const polygon = new ol.geom.Polygon([points]);

	  if (strefaStore[id]) {
		strefaStore[id].setGeometry(polygon);
	  } else {
		const feature = new ol.Feature(polygon);
		feature.set('id', id);
		strefaLayer.getSource().addFeature(feature);
		strefaStore[id] = feature;
	  }
	  aktualizujMaske();
	}

	function rm_zone(id) {
	  const feature = strefaStore[id];
	  if (feature) {
		strefaLayer.getSource().removeFeature(feature);
		delete strefaStore[id];
	  }
	  aktualizujMaske();
	}

    function point(nazwaPliku,lo, la) {
	  const geometry = new ol.geom.Point(ol.proj.fromLonLat([lo, la]));

	  if (markerStore[nazwaPliku]) {
		const feature = markerStore[nazwaPliku];
		feature.setGeometry(geometry);

		if (!markersLayer.getSource().getFeatures().includes(feature)) {
		  markersLayer.getSource().addFeature(feature);
		}
	  } else {
		const marker = new ol.Feature({ geometry });
		marker.setStyle(new ol.style.Style({
		  image: new ol.style.Icon({
			anchor: [0.5, 1],
			src: nazwaPliku + '.png',
			scale: 0.50
		  })
		}));
		markersLayer.getSource().addFeature(marker);
		markerStore[nazwaPliku] = marker;
	  }
	}


    function rm_point(nazwaPliku) {
      if (markerStore[nazwaPliku]) {
        markersLayer.getSource().removeFeature(markerStore[nazwaPliku]);
      }
    }
	
	
	

    // Funkcja aktualizująca maskę - tworzy wielokąt z dziurami w miejscach stref
    function aktualizujMaske() {
	  const reader = new jsts.io.OL3Parser();
	  const writer = new jsts.io.OL3Parser();

	  // Tworzymy geometrię świata (prostokąt)
	  const worldGeom = new ol.geom.Polygon([worldCoords]);
	  let jstsWorld = reader.read(worldGeom);

	  // Budujemy unię wszystkich stref
	  let unionGeom = null;
	  for (const id in strefaStore) {
		const olGeom = strefaStore[id].getGeometry();
		let jstsGeom = reader.read(olGeom);
		if (!unionGeom) {
		  unionGeom = jstsGeom;
		} else {
		  unionGeom = unionGeom.union(jstsGeom);
		}
	  }

	  if (unionGeom) {
		// Różnica: świat minus unia stref
		const maskJsts = jstsWorld.difference(unionGeom);
		const maskPolygon = writer.write(maskJsts);

		let maskFeature = maskSource.getFeatures()[0];
		if (!maskFeature) {
		  maskFeature = new ol.Feature(maskPolygon);
		  maskSource.addFeature(maskFeature);
		} else {
		  maskFeature.setGeometry(maskPolygon);
		}
	  } else {
		// brak stref -> cała mapa jest zacieniona
		const maskFeature = maskSource.getFeatures()[0];
		if (maskFeature) {
		  maskSource.removeFeature(maskFeature);
		}
	  }
	}
	
	function center(lo, la) {
	  const view = map.getView();
	  const coord = ol.proj.fromLonLat([lo, la]);
	  view.animate({center: coord, duration: 500});
	}


   	markersLayer.setZIndex(999);
	
	aktualizujMaske();
	
	

  </script>
</body>
</html>