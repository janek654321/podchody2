<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" />
  <title>Mapa</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
  <style>
    html, body, #map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
	#selectionCircle, #infoBox, #crosshair {
	  display: none;
	}

	#selectionCircle {
	  position: absolute;
	  top: 50%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  width: min(90vw, 90vh);
	  height: min(90vw, 90vh);
	  border: 4px dashed black;
	  border-radius: 50%;
	  pointer-events: none;
	  z-index: 10;
	  display: none;
	}

	#crosshair {
	  position: absolute;
	  top: 50%;
	  left: 50%;
	  width: 40px;      /* długość ramion krzyża */
	  height: 40px;
	  transform: translate(-50%, -50%);
	  pointer-events: none;
	  z-index: 11;
	}

	#crosshair::before,
	#crosshair::after {
	  content: '';
	  position: absolute;
	  background: black;
	}

	#crosshair::before {
	  top: 50%;
	  left: 0;
	  right: 0;
	  height: 2px;          /* grubość poziomej linii */
	  transform: translateY(-50%);
	}

	#crosshair::after {
	  top: 0;
	  bottom: 0;
	  left: 50%;
	  width: 2px;           /* grubość pionowej linii */
	  transform: translateX(-50%);
	}

	#infoBox {
	  position: absolute;
	  top: 10px;
	  left: 50%;
	  transform: translateX(-50%);
	  background-color: rgba(0, 0, 0, 0.7);
	  color: white;
	  padding: 10px 16px;
	  border-radius: 10px;
	  z-index: 20;
	  font-size: 16px;
	  text-align: center;
	  cursor: pointer;
	}

	.center-btn {
	  position: absolute;
	  top: 79px;
	  left: 9px;
	  background-color: white;
	  border: solid gainsboro;
	  border-radius: 2px;
	  width: 33px;
	  height: 33px;
	  padding: 0;
	  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
	  cursor: pointer;
	  transition: background-color 0.2s, box-shadow 0.2s;
	  z-index: 1000;

	  display: flex;
	  justify-content: center;
	  align-items: center;
	}

	.center-btn img {
	  width: 22px;
	  height: 22px;
	  user-select: none;
	  pointer-events: none;
	}

	.center-btn.active {
	  background-color: #d0f0ff;
	  box-shadow: 0 0 0 2px #4fc3f7;
	}

  </style>
</head>
<body>
  <div id="map"></div>
  <div id="selectionCircle"></div>
  <div id="crosshair"></div>
  <div id="infoBox">Kliknij tutaj, aby wybrać to miejsce</div>
  <button id="centerButton" class="center-btn">
  <img id="centerIcon" src="gps.png" alt="Center">
</button>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script src="https://unpkg.com/jsts@2.6.1/dist/jsts.min.js"></script>
  <script>

	const koloryStref = {
	  1: 'red',
	  2: 'orange',
	  3: 'black'
	};
	
  
    const map = new ol.Map({
      target: 'map',
      layers: [
        new ol.layer.Tile({ source: new ol.source.OSM()	})
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([18.6, 53.02]),
        zoom: 13
      })
    });

	
	const strefaStore = {};

	const strefaLayer = new ol.layer.Vector({
	  source: new ol.source.Vector(),
	  style: feature => {
		const id = feature.get('id');
		return new ol.style.Style({
		  stroke: new ol.style.Stroke({
			color: koloryStref[id] || 'black',
			width: 3
		  }),
		  fill: null
		});
	  }
	});
	map.addLayer(strefaLayer);
	
	
	
	const maskSource = new ol.source.Vector();
    const maskLayer = new ol.layer.Vector({
      source: maskSource,
      style: new ol.style.Style({
        stroke: null,
        fill: new ol.style.Fill({
          color: 'rgba(100,0,0,0.4)'
        })
      }),
      zIndex: 100
    });
    map.addLayer(maskLayer);
    const extent = ol.proj.get('EPSG:3857').getExtent();
    const worldCoords = [
      [-20037508.342789244, 20037508.342789244],  // NW
      [20037508.342789244, 20037508.342789244],   // NE
      [20037508.342789244, -20037508.342789244],  // SE
      [-20037508.342789244, -20037508.342789244], // SW
      [-20037508.342789244, 20037508.342789244]   // zamknięcie NW
    ];
	
		
	
	
    const markersLayer = new ol.layer.Vector({
      source: new ol.source.Vector()
    });
    map.addLayer(markersLayer);

    const markerStore = {};
	
	const scaleLineControl = new ol.control.ScaleLine();
	map.addControl(scaleLineControl);
	
    function computeDestinationPoint([lon, lat], distance, bearing) {
      const R = 6371000;
      const δ = distance / R;
      const θ = bearing * Math.PI / 180;
      const φ1 = lat * Math.PI / 180;
      const λ1 = lon * Math.PI / 180;
      const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) +
                             Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));
      const λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(δ) * Math.cos(φ1),
                                 Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
      return [λ2 * 180 / Math.PI, φ2 * 180 / Math.PI];
    }

    function zone(id, lo, la, promienMetry) {
	  const center = [lo, la];
	  const radius = promienMetry;

	  const points = [];
	  const numPoints = 64;

	  for (let i = 0; i < numPoints; ++i) {
		const angleDeg = (360 * i) / numPoints;
		const dest = computeDestinationPoint(center, radius, angleDeg);
		points.push(ol.proj.fromLonLat(dest));
	  }
	  points.push(points[0]);

	  const polygon = new ol.geom.Polygon([points]);

	  if (strefaStore[id]) {
		strefaStore[id].setGeometry(polygon);
	  } else {
		const feature = new ol.Feature(polygon);
		feature.set('id', id);
		strefaLayer.getSource().addFeature(feature);
		strefaStore[id] = feature;
	  }
	  aktualizujMaske();
	}

	function rm_zone(id) {
	  const feature = strefaStore[id];
	  if (feature) {
		strefaLayer.getSource().removeFeature(feature);
		delete strefaStore[id];
	  }
	  aktualizujMaske();
	}

    function point(nazwaPliku,lo, la) {
	  const geometry = new ol.geom.Point(ol.proj.fromLonLat([lo, la]));

	  if (markerStore[nazwaPliku]) {
		const feature = markerStore[nazwaPliku];
		feature.setGeometry(geometry);

		if (!markersLayer.getSource().getFeatures().includes(feature)) {
		  markersLayer.getSource().addFeature(feature);
		}
	  } else {
		const marker = new ol.Feature({ geometry });
		marker.setStyle(new ol.style.Style({
		  image: new ol.style.Icon({
			anchor: [0.5, 1],
			src: nazwaPliku + '.png',
			scale: 0.50
		  })
		}));
		markersLayer.getSource().addFeature(marker);
		markerStore[nazwaPliku] = marker;
	  }
	  setTimeout(aktualizujCentrowanie, 2);
	}


    function rm_point(nazwaPliku) {
      if (markerStore[nazwaPliku]) {
        markersLayer.getSource().removeFeature(markerStore[nazwaPliku]);
      }
    }
	
	
	

    // Funkcja aktualizująca maskę - tworzy wielokąt z dziurami w miejscach stref
    function aktualizujMaske() {
	  const reader = new jsts.io.OL3Parser();
	  const writer = new jsts.io.OL3Parser();

	  // Tworzymy geometrię świata (prostokąt)
	  const worldGeom = new ol.geom.Polygon([worldCoords]);
	  let jstsWorld = reader.read(worldGeom);

	  // Budujemy unię wszystkich stref
	  let unionGeom = null;
	  for (const id in strefaStore) {
		const olGeom = strefaStore[id].getGeometry();
		let jstsGeom = reader.read(olGeom);
		if (!unionGeom) {
		  unionGeom = jstsGeom;
		} else {
		  unionGeom = unionGeom.union(jstsGeom);
		}
	  }

	  if (unionGeom) {
		// Różnica: świat minus unia stref
		const maskJsts = jstsWorld.difference(unionGeom);
		const maskPolygon = writer.write(maskJsts);

		let maskFeature = maskSource.getFeatures()[0];
		if (!maskFeature) {
		  maskFeature = new ol.Feature(maskPolygon);
		  maskSource.addFeature(maskFeature);
		} else {
		  maskFeature.setGeometry(maskPolygon);
		}
	  } else {
		// brak stref -> cała mapa jest zacieniona
		const maskFeature = maskSource.getFeatures()[0];
		if (maskFeature) {
		  maskSource.removeFeature(maskFeature);
		}
	  }
	}
		
	let trybWybierania = false;

	function set_center() {
	  trybWybierania = true;
	  document.getElementById('selectionCircle').style.display = 'block';
	  document.getElementById('crosshair').style.display = 'block';
	  document.getElementById('infoBox').style.display = 'block';
	}
	

	
	document.getElementById('infoBox').addEventListener('click', () => {
	  if (!trybWybierania) return;

	  const center = ol.proj.toLonLat(map.getView().getCenter());
	  const lon = center[0].toFixed(6);
	  const lat = center[1].toFixed(6);
	  const result = `${lon}#${lat}`;

	  if (window.AppInventor) {
		window.AppInventor.setWebViewString(result);
	  } 

	  trybWybierania = false;
	  document.getElementById('selectionCircle').style.display = 'none';
	  document.getElementById('crosshair').style.display = 'none';
	  document.getElementById('infoBox').style.display = 'none';
	});
	
	
	let autoCentering = false;

	document.getElementById("centerButton").addEventListener("click", () => {
	  autoCentering = true;
	  const button = document.getElementById("centerButton");
	  button.classList.toggle("active", autoCentering);
	  aktualizujCentrowanie();
	});
	
	map.on('pointerdrag', () => {
	  if (autoCentering) {
		autoCentering = false;
		const button = document.getElementById("centerButton");
		button.classList.toggle("active", autoCentering);
	  }
	});
	
	function aktualizujCentrowanie() {
	  if (!autoCentering) return;
	  const feature = Object.entries(markerStore).find(([key]) => key.includes('x'))?.[1];
	  if (feature) {
		const coords = feature.getGeometry().getCoordinates();
		map.getView().animate({
		  center: coords,
		  duration: 500
		});
	  }
	}


   	markersLayer.setZIndex(999);
	
	aktualizujMaske();
	
	

  </script>
</body>
</html>